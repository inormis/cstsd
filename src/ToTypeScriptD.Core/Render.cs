using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using ToTypeScriptD.Core;
using ToTypeScriptD.Core.TypeWriters;

namespace ToTypeScriptD
{
    public class Render
    {
        public static bool AllAssemblies(ConfigBase config, TextWriter w)
        {
           config.AssemblyPaths
                = config.AssemblyPaths.Select(path => new System.IO.FileInfo(path).FullName).ToArray();

            w.Write(GetHeader(config.AssemblyPaths, config.IncludeSpecialTypes));

            var typeCollection = new TypeCollection(config.GetTypeWriterTypeSelector());

            var wroteAnyTypes = WriteSpecialTypes(config.IncludeSpecialTypes, w, config);
            wroteAnyTypes |= WriteFiles(config.AssemblyPaths, w, config.TypeNotFoundErrorHandler, typeCollection, config.RegexFilter, config);
            return wroteAnyTypes;
        }

        //TODO: rename FromFiles (usage: Render.FromFiles())
        /// <summary>
        /// This is the main entry point to rendering the output.
        /// </summary>
        /// <param name="assemblyPaths">Must be absolute file paths.</param>
        /// <param name="w">TextWriter stream to use.</param>
        /// <param name="typeNotFoundErrorHandler">Error handler to use when type reference is not found in loaded assemblies.</param>
        /// <param name="typeCollection">Collected types to render.</param>
        /// <param name="filterRegex">Filter type names using regular expression string.</param>
        /// <param name="config">Output configuration.</param>
        /// <returns></returns>
        private static bool WriteFiles(IEnumerable<string> assemblyPaths, TextWriter w, ITypeNotFoundErrorHandler typeNotFoundErrorHandler, TypeCollection typeCollection, string filterRegex, ConfigBase config)
        {
            var filesAlreadyProcessed = new HashSet<string>(new IgnoreCaseStringEqualityComparer());

            var any = false;

            //scan all assembly paths
            assemblyPaths.Each(assemblyPath =>
            {
                any = true;
                if (filesAlreadyProcessed.Contains(assemblyPath))
                    return;

                filesAlreadyProcessed.Add(assemblyPath);
                //collect types to render
                CollectTypes(assemblyPath, typeNotFoundErrorHandler, typeCollection, config);
            });

            if (any == false)
                return false;

            //render collected types
            var renderedOut = typeCollection.Render(filterRegex);
            w.WriteLine(renderedOut);

            return true;
        }

        private static bool WriteSpecialTypes(bool includeSpecialTypes, TextWriter w, ConfigBase config)
        {
            if (!includeSpecialTypes)
                return false;

            w.NewLine();

            w.WriteLine(Resources.ToTypeScriptDSpecialTypes_d.Replace("    ", config.Indent));
            w.NewLine();
            w.NewLine();
            return true;
        }

        public static string FullAssembly(string assemblyPath, TypeCollection typeCollection, ConfigBase config)
        {
            CollectTypes(assemblyPath, config.TypeNotFoundErrorHandler, typeCollection, config);
            return GetHeader(new[] { assemblyPath }, config.IncludeSpecialTypes) + typeCollection.Render(config.RegexFilter);
        }

        private static string GetHeader(IEnumerable<string> assemblyPaths, bool forceDueToSpecialType)
        {
            if (!forceDueToSpecialType && !assemblyPaths.Any())
            {
                return "";
            }

            if (!assemblyPaths.All(File.Exists))
            {
                return "";
            }

            var sb = new StringBuilder();
            sb.AppendFormatLine("//****************************************************************");
            sb.AppendFormatLine("//  Generated by:  ToTypeScriptD");
            sb.AppendFormatLine("//  Website:       http://github.com/ToTypeScriptD/ToTypeScriptD");
            sb.AppendFormatLine("//  Version:       {0}", System.Diagnostics.FileVersionInfo.GetVersionInfo(typeof(Render).Assembly.Location).ProductVersion);
            sb.AppendFormatLine("//  Date:          {0}", DateTime.Now);
            if (assemblyPaths.Any())
            {
                sb.AppendFormatLine("//");
                sb.AppendFormatLine("//  Assemblies:");
                assemblyPaths
                    .Select(System.IO.Path.GetFileName)
                    .Distinct()
                    .OrderBy(s => s)
                    .Each(path =>
                    {
                        sb.AppendFormatLine("//    {0}", System.IO.Path.GetFileName(path));
                    });
                sb.AppendFormatLine("//");
            }
            sb.AppendFormatLine("//****************************************************************");
            sb.AppendFormatLine();
            sb.AppendFormatLine();
            sb.AppendFormatLine();
            return sb.ToString();
        }

        private static void CollectTypes(string assemblyPath, ITypeNotFoundErrorHandler typeNotFoundErrorHandler, TypeCollection typeCollection, ConfigBase config)
        {
            var assembly = Assembly.LoadFile(assemblyPath);

            typeCollection.AddAssembly(assembly);

            var typeWriterGenerator = new TypeWriterCollector(typeNotFoundErrorHandler, typeCollection.TypeSelector);
            foreach (var item in assembly.ManifestModule.GetTypes())
            {
                typeWriterGenerator.Collect(item, typeCollection, config);
            }
        }

    }
}
